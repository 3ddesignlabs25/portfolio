<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projects | Michael Butler</title>
  <meta name="description" content="Help-desk-focused projects demonstrating systems setup, troubleshooting, scripting, and iterative learning across Linux, Python, and embedded tooling." />
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <header class="site-header">
    <div class="container header-inner">
      <a class="brand" href="index.html" aria-label="Home">
        <span class="brand-mark" aria-hidden="true">MB</span>
        <span class="brand-text">
          <span class="brand-name">Michael Butler</span>
          <span class="brand-sub">Technical Support • Systems</span>
        </span>
      </a>

      <nav class="nav" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="projects.html">Projects</a>
        <a href="troubleshooting.html">Troubleshooting</a>
        <a href="resume.html">Resume</a>
        <a href="contact.html">Contact</a>
      </nav>
    </div>
  </header>

  <main id="main" class="main">
    <!-- ========================= -->
    <!-- PROJECT 01: ACTIVE PROJECT -->
    <!-- ========================= -->

    <section class="hero">
      <div class="container">
        <p class="kicker">Project</p>

        <h1 class="headline">Raspberry Pi Python Sandbox</h1>

        <p class="summary">
          A portable Python sandbox built on a Raspberry Pi to safely develop, test,
          and troubleshoot scripts in isolated environments. Designed to mirror
          real technical support workflows, emphasize reproducibility, and support
          future multi-language expansion.
        </p>

        <dl class="meta">
          <div class="meta-row">
            <dt>Role</dt>
            <dd>Designer • Builder • Troubleshooter</dd>
          </div>
          <div class="meta-row">
            <dt>Tools</dt>
            <dd>Raspberry Pi Zero 2 W, Linux, Python, Bash, SSH, Git</dd>
          </div>
          <div class="meta-row">
            <dt>Status</dt>
            <dd>Active / Expanding</dd>
          </div>
        </dl>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>Problem</h2>
        <p>
          Learning and testing Python across multiple systems frequently led to
          broken environments, dependency conflicts, and inconsistent results.
          I needed a controlled, repeatable sandbox that could be rebuilt quickly
          and accessed remotely for troubleshooting practice.
        </p>
      </div>
    </section>

   <section class="section">
  <div class="container">
    <h2>Constraints</h2>
    <ul>
      <li>Limited hardware resources on the Raspberry Pi Zero 2 W, requiring efficient tooling and lightweight workflows</li>
      <li>System must support both local hardware testing and external device deployment without cross-interference</li>
      <li>All development and testing must be operable from a terminal-first environment</li>
      <li>Environments must be disposable, reproducible, and recoverable through scripting</li>
      <li>Hardware testing (servos, LEDs, peripherals) must be isolated from target deployment devices</li>
      <li>The system must remain portable and self-contained, supporting an eventual cyberdeck form factor</li>
    </ul>
  </div>
</section>

   <section class="section">
  <div class="container">
    <h2>System Overview</h2>
    <p>
      The system is built around a Raspberry Pi acting as the primary host,
      development environment, and deployment controller. The Pi runs a structured
      Linux-based workspace where Python virtual environments, build tools, and
      scripts are used to develop and test code in a controlled manner.
    </p>
    <p>
      An ESP32-C6 with a 1.47-inch LCD is integrated as a local hardware test
      interface. This built-in microcontroller is used to execute scripts, drive
      servos and LEDs, and provide immediate visual feedback without risking
      external devices. It functions as a safe, always-available test target.
    </p>
    <p>
      The Raspberry Pi is also responsible for flashing and deploying code to
      external target ESP devices. This separation allows the built-in ESP32-C6
      to be used for validation and diagnostics while the Pi handles programming
      and verification of additional hardware.
    </p>
    <p>
      Together, this architecture supports multi-language development (Python,
      C/C++, and Rust), emphasizes fault isolation, and mirrors real-world
      troubleshooting and deployment workflows commonly used in technical support
      and embedded systems environments.
    </p>
  </div>
</section>


    <section class="section">
      <div class="container">
        <h2>What Worked</h2>
        <ul>
          <li>Virtual environments eliminated cross-project conflicts</li>
          <li>SSH-only workflow reinforced real support scenarios</li>
          <li>Automated setup reduced manual configuration errors</li>
          <li>Quick recovery by rebuilding environments from script</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>What Didn’t</h2>
        <ul>
          <li>System updates occasionally invalidated environments</li>
          <li>Initial confusion between system Python and venv Python</li>
          <li>Performance limits on heavier workloads</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>How I Debugged It</h2>
        <ol>
          <li>Confirmed active Python interpreter and PATH</li>
          <li>Validated virtual environment activation</li>
          <li>Checked installed packages and versions</li>
          <li>Rebuilt environments when state was ambiguous</li>
          <li>Documented steps to ensure repeatability</li>
        </ol>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>Current State</h2>
        <p>
          The sandbox is stable and used regularly for Python development and
          troubleshooting practice. It serves as a safe test platform for learning
          without risking system-wide configuration issues.
        </p>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>Next Steps</h2>
        <ul>
          <li>Add a C++ build and test workflow</li>
          <li>Introduce Rust tooling alongside Python</li>
          <li>Expand automation within the setup script</li>
          <li>Document recovery steps as a support runbook</li>
        </ul>
      </div>
    </section>

    <section class="section">
  <div class="container">
    <h2>End Goal</h2>
    <p>
      The long-term goal is to evolve this sandbox into a self-contained
      Raspberry Pi–based coding cyberdeck with an integrated keyboard and display,
      functioning as a portable development and testing workstation.
    </p>
    <p>
      The cyberdeck will pair the Raspberry Pi with an ESP32-C6 featuring a
      1.47-inch LCD, where the ESP32 acts as a local I/O and hardware test interface.
      This built-in ESP will be used for rapid script execution, servo testing,
      LED control, and real-time feedback without risking external hardware.
    </p>
    <p>
      The Raspberry Pi will serve as the primary controller and deployment node,
      capable of compiling, running, and uploading code to both the integrated
      ESP32-C6 and separate target ESP devices. This allows safe local testing on
      the built-in ESP while using the Pi to flash and validate code on external
      microcontrollers.
    </p>
    <p>
      This architecture reinforces system separation, fault isolation, and
      repeatable workflows while supporting multi-language development in Python,
      C/C++, and Rust directly from the terminal.
    </p>
  </div>
</section>

    <section class="section">
      <div class="container">
        <h2>Code & Artifacts</h2>

        <ul>
          <li>
            <strong>setup.sh</strong> —
            <a href="assets/code/pi-py-sandbox-setup.sh">View raw file</a>
          </li>
        </ul>

        <h3>setup.sh (Inline)</h3>
        <p class="muted">
          Bash script used to automate Raspberry Pi sandbox setup, dependency
          installation, and Python environment initialization.
        </p>

        <pre><code>
#!/usr/bin/env bash
set -euo pipefail

# Print the absolute path of this script
realpath "$0"

# Configuration
SANDBOX_ROOT="/home/raspberry/sandbox"
VENV_DIR="$SANDBOX_ROOT/venv"
BOOTSTRAP_SH="$SANDBOX_ROOT/bootstrap.sh"
BASHRC="/home/raspberry/.bashrc"

# Update system packages
sudo apt-get update
sudo apt-get -y upgrade

# Install required packages
sudo apt-get install -y \
  python3 python3-pip python3-venv \
  git tmux screen \
  build-essential minicom

# Create sandbox directory structure
mkdir -p "$SANDBOX_ROOT"/{venv,experiments,esp_tools,protocols,tests,logs}

# Create Python virtual environment if missing
if [ ! -d "$VENV_DIR" ]; then
  python3 -m venv "$VENV_DIR"
fi

# Install Python packages into the venv
"$VENV_DIR/bin/pip" install --upgrade pip
"$VENV_DIR/bin/pip" install pyserial esptool requests flask rich click

# Create bootstrap script to activate the venv
cat <<'BOOTSTRAP' > "$BOOTSTRAP_SH"
#!/usr/bin/env bash
# Safe to source multiple times
if [ -n "${VIRTUAL_ENV:-}" ] && [ "$VIRTUAL_ENV" = "/home/raspberry/sandbox/venv" ]; then
  return 0 2>/dev/null || exit 0
fi

source "/home/raspberry/sandbox/venv/bin/activate"
python --version
printf "Sandbox path: %s\n" "/home/raspberry/sandbox"
BOOTSTRAP

chmod +x "$BOOTSTRAP_SH"

# Ensure .bashrc auto-activates sandbox for interactive shells only
if ! grep -q "sandbox/bootstrap.sh" "$BASHRC"; then
  cat <<'BASHRC_SNIPPET' >> "$BASHRC"

# Auto-activate Raspberry Pi sandbox for interactive shells
if [[ $- == *i* ]]; then
  if [ -f "/home/raspberry/sandbox/bootstrap.sh" ]; then
    source "/home/raspberry/sandbox/bootstrap.sh"
  fi
fi
BASHRC_SNIPPET
fi

# Add user to dialout group for serial access
sudo usermod -aG dialout raspberry

# Reboot reminder
printf "\nSetup complete. Please reboot the Raspberry Pi for group changes to take effect.\n"
        </code></pre>
      </div>
    </section>

    <!-- ===================================================== -->
    <!-- PROJECT TEMPLATE (ANNOTATED – COPY OR UNCOMMENT LATER) -->
    <!-- ===================================================== -->

    <!--
    <section class="section">
      <div class="container">
        <h2>End Goal</h2>
        <p>
          [Describe the intended final form of the project. Focus on system-level
          capability, portability, or operational use.]
        </p>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>Code & Artifacts</h2>
        <ul>
          <li><strong>[script.sh]</strong> — [What the script does]</li>
        </ul>
        <pre><code>
# Paste code here
        </code></pre>
      </div>
    </section>
    -->
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <p class="muted">© <span id="year"></span> Michael Butler. Built for clarity and support roles.</p>
    </div>
  </footer>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>
</body>
</html>

