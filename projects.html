<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projects | Michael Butler</title>
  <meta name="description" content="Help-desk-focused projects demonstrating systems setup, troubleshooting, scripting, and iterative learning across Linux, Python, and embedded tooling." />
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <header class="site-header">
    <div class="container header-inner">
      <a class="brand" href="index.html" aria-label="Home">
        <span class="brand-mark" aria-hidden="true">MB</span>
        <span class="brand-text">
          <span class="brand-name">Michael Butler</span>
          <span class="brand-sub">Technical Support • Systems</span>
        </span>
      </a>

      <nav class="nav" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="projects.html">Projects</a>
        <a href="troubleshooting.html">Troubleshooting</a>
        <a href="resume.html">Resume</a>
        <a href="contact.html">Contact</a>
      </nav>
    </div>
  </header>

  <main id="main" class="main">
    <!-- ========================= -->
    <!-- PROJECT 01: ACTIVE PROJECT -->
    <!-- ========================= -->

    <section class="hero">
      <div class="container">
        <p class="kicker">Project</p>

        <h1 class="headline">Raspberry Pi Python Sandbox</h1>

        <p class="summary">
          A portable Python sandbox built on a Raspberry Pi to safely develop, test,
          and troubleshoot scripts in isolated environments. Designed to mirror
          real technical support workflows, emphasize reproducibility, and support
          future multi-language expansion.
        </p>

        <dl class="meta">
          <div class="meta-row">
            <dt>Role</dt>
            <dd>Designer • Builder • Troubleshooter</dd>
          </div>
          <div class="meta-row">
            <dt>Tools</dt>
            <dd>Raspberry Pi Zero 2 W, Linux, Python, Bash, SSH, Git</dd>
          </div>
          <div class="meta-row">
            <dt>Status</dt>
            <dd>Active / Expanding</dd>
          </div>
        </dl>
      </div>
    </section>

    <section class="section">
  <div class="container">
    <h2>Problem</h2>
    <p>
      I wanted a way to learn and experiment with Python in a controlled, low-risk
      environment that did not rely on full IDE setups or interfere with my primary
      computer. Using local development environments made it easy to accidentally
      break system configurations or lose track of what changes affected which
      projects.
    </p>
    <p>
      I also needed a solution that was portable and flexible enough to be used
      outside of a traditional desktop workflow. The goal was to have a dedicated
      system where experimentation, mistakes, and rebuilding environments were
      expected, without the overhead of managing multiple IDEs or risking existing
      setups.
    </p>
    <p>
      This project was created to provide a self-contained Python sandbox that could
      support learning, experimentation, and troubleshooting in a way that mirrors
      real system workflows while remaining safe, disposable, and easy to rebuild.
    </p>
  </div>
</section>



  <section class="section">
  <div class="container">
    <h2>Constraints</h2>
    <ul>
      <li>Current implementation is limited to a single Raspberry Pi system without external microcontroller integration</li>
      <li>Hardware resources are constrained by the Raspberry Pi Zero 2 W, requiring lightweight tooling and careful resource use</li>
      <li>All development and testing must be performed in a terminal-based Linux environment</li>
      <li>Python environments must be isolated to avoid system-level dependency conflicts</li>
      <li>The system must remain simple enough to rebuild quickly when configurations break</li>
      <li>Future expansion must not require reworking the existing sandbox foundation</li>
    </ul>
  </div>
</section>

   

   <section class="section">
     <div class="container">
       
     <h2>End Goal</h2>
    <p>
      The long-term goal is to evolve this sandbox into a self-contained
      Raspberry Pi–based coding cyberdeck with an integrated keyboard and display,
      functioning as a portable development and testing workstation.
    </p>
    <p>
      The cyberdeck will pair the Raspberry Pi with an ESP32-C6 featuring a
      1.47-inch LCD, where the ESP32 acts as a local I/O and hardware test interface.
      This built-in ESP will be used for rapid script execution, servo testing,
      LED control, and real-time feedback without risking external hardware.
    </p>
    <p>
      The Raspberry Pi will serve as the primary controller and deployment node,
      capable of compiling, running, and uploading code to both the integrated
      ESP32-C6 and separate target ESP devices. This allows safe local testing on
      the built-in ESP while using the Pi to flash and validate code on external
      microcontrollers.
    </p>
    <p>
      This architecture reinforces system separation, fault isolation, and
      repeatable workflows while supporting multi-language development in Python,
      C/C++, and Rust directly from the terminal.
    </p>
  </div>
</section> 
 <section class="section">
  <div class="container">   
    <h2>System Overview</h2>
    <p>
      The intended system architecture centers around a Raspberry Pi acting as a
      portable development host, automation controller, and deployment node. The Pi
      runs a Linux-based workspace where scripts, build tools, and language runtimes
      are managed through isolated environments and reproducible setup processes.
    </p>
    <p>
      A Python sandbox forms the foundation of the system, providing a controlled
      space for scripting, testing, and troubleshooting. This sandbox is designed
      to support expansion into additional languages such as C/C++ and Rust while
      maintaining clear separation between projects and dependencies.
    </p>
    <p>
      An ESP32-C6 with a 1.47-inch LCD is planned as an integrated hardware test and
      interaction layer. This microcontroller will be used for rapid validation of
      scripts, testing servos and LEDs, and providing immediate visual feedback without
      risking external hardware.
    </p>
    <p>
      The Raspberry Pi will also serve as the primary interface for flashing and
      managing external target ESP devices. This separation allows the built-in
      ESP32-C6 to function as a safe test platform while the Pi handles programming,
      verification, and deployment to additional hardware.
    </p>
    <p>
      Together, this architecture emphasizes isolation of responsibilities, fault
      containment, and repeatable workflows, closely mirroring professional system
      administration, embedded development, and technical support environments.
    </p>
  </div>
</section>

    <section class="section">
  <div class="container">
    <h2>What Worked</h2>
    <ul>
      <li>
        <strong>Isolated Python virtual environments.</strong><br />
        Using virtual environments consistently prevented system-level package
        conflicts and allowed individual projects to install and modify dependencies
        without affecting other work or the base OS.
      </li>
      <li>
        <strong>Terminal-first workflow.</strong><br />
        Performing all development and troubleshooting through the terminal (locally
        and over SSH) reinforced disciplined workflows and made environment state more
        visible and predictable.
      </li>
      <li>
        <strong>Intentional failure and recovery.</strong><br />
        Treating environment breakage as expected behavior rather than an exception
        made it easier to diagnose issues and rebuild cleanly instead of attempting
        risky partial fixes.
      </li>
      <li>
        <strong>Automation through scripting.</strong><br />
        Using a setup script to handle package installation and environment creation
        reduced manual errors and made system recovery faster and more consistent.
      </li>
      <li>
        <strong>Dedicated hardware for experimentation.</strong><br />
        Keeping the sandbox isolated to a single Raspberry Pi allowed unrestricted
        experimentation without concern for breaking primary development machines.
      </li>
    </ul>
  </div>
</section>


   <section class="section">
  <div class="container">
    <h2>What Didn’t</h2>
    <ul>
      <li>
        <strong>Environment fragility after system updates.</strong><br />
        OS-level updates occasionally invalidated virtual environments, requiring
        manual intervention or full rebuilds when Python versions or shared libraries
        changed.
      </li>
      <li>
        <strong>Ambiguity between system Python and virtual environments.</strong><br />
        Early on, it was easy to unintentionally run scripts against the system Python
        interpreter, leading to misleading errors and inconsistent behavior.
      </li>
      <li>
        <strong>Limited visibility into partial failures.</strong><br />
        Some dependency issues failed silently or surfaced only at runtime, making
        root-cause analysis slower without deliberate inspection of environment state.
      </li>
      <li>
        <strong>Manual setup overhead during iteration.</strong><br />
        Until automation was introduced, rebuilding environments required repetitive
        manual steps, increasing the likelihood of configuration drift.
      </li>
      <li>
        <strong>Hardware performance constraints.</strong><br />
        The Raspberry Pi Zero 2 W imposed limits on compile times and parallel workloads,
        reinforcing the need for lightweight tooling and staged expansion.
      </li>
    </ul>
  </div>
</section>


   <section class="section">
  <div class="container">
    <h2>How I Debugged It</h2>
    <ol>
      <li>
        <strong>Confirmed the active execution context.</strong><br />
        Verified which Python interpreter was being used by checking paths and
        executable locations. This ensured scripts were not accidentally running
        against the system Python instead of the virtual environment.
      </li>
      <li>
        <strong>Validated environment activation and isolation.</strong><br />
        Explicitly activated the virtual environment and confirmed environment
        variables such as <code>VIRTUAL_ENV</code> and <code>PATH</code> were set
        correctly. This helped rule out partial or failed activations.
      </li>
      <li>
        <strong>Inspected installed dependencies.</strong><br />
        Reviewed installed packages and versions within the virtual environment
        to identify missing, outdated, or conflicting dependencies that could
        explain unexpected behavior.
      </li>
      <li>
        <strong>Reproduced failures intentionally.</strong><br />
        Re-ran failing scripts in a controlled manner to ensure issues were
        repeatable rather than intermittent. This helped distinguish logic errors
        from environment-related problems.
      </li>
      <li>
        <strong>Reset and rebuilt when state became unclear.</strong><br />
        When troubleshooting paths became ambiguous, the environment was torn
        down and rebuilt using documented steps and scripts. This verified whether
        issues were configuration-based or code-based.
      </li>
      <li>
        <strong>Documented recovery steps.</strong><br />
        Notes were taken during debugging to capture failure patterns and recovery
        procedures, reinforcing repeatability and reducing future troubleshooting
        time.
      </li>
    </ol>
  </div>
</section>


    <section class="section">
  <div class="container">
    <h2>Current State</h2>
    <p>
      The current implementation is a bare Raspberry Pi configured as a dedicated
      Python development sandbox. The system runs Raspberry Pi OS and is used
      exclusively for experimentation, scripting, and troubleshooting without
      affecting primary machines or production environments.
    </p>
    <p>
      A Python virtual environment is fully set up and serves as the primary workspace.
      This allows packages, dependencies, and test scripts to be installed, modified,
      and removed freely without risking system-level breakage. When environments
      become unstable, they can be rebuilt quickly using documented steps and
      automation scripts.
    </p>
    <p>
      At this stage, the focus is intentionally narrow: validating environment
      isolation, practicing recovery from broken states, and reinforcing disciplined
      troubleshooting habits. No external hardware integration or deployment targets
      are currently in use, allowing failures to be explored safely and repeatedly.
    </p>
    <p>
      This foundation establishes a reliable baseline on which additional tooling,
      hardware interfaces, and automation can be layered without compromising system
      stability.
    </p>
  </div>
</section>

   <section class="section">
  <div class="container">
    <h2>Next Steps</h2>
    <ul>
      <li>
        <strong>Expand language support.</strong><br />
        Incrementally add support for additional mainstream programming languages
        beyond Python, C/C++, and Rust. This includes languages such as Java,
        JavaScript/Node.js, Go, Lua, and others commonly used in scripting,
        automation, and systems work, with the goal of running them directly
        from a single Raspberry Pi environment.
      </li>
      <li>
        <strong>Evaluate multi-Pi language separation.</strong><br />
        Experiment with running alternate Raspberry Pi systems dedicated to
        specific language stacks when isolation or tooling conflicts arise,
        while keeping the primary focus on consolidating as many workflows as
        possible onto one main system.
      </li>
      <li>
        <strong>Establish basic deployment tooling.</strong><br />
        Implement scripts and procedures for uploading and managing code on
        external target ESP devices, using the Raspberry Pi as the central
        control and orchestration point.
      </li>
      <li>
        <strong>Integrate local hardware testing.</strong><br />
        Begin incorporating an ESP32-C6 with a small display as a dedicated
        hardware test interface for validating scripts, testing servos and LEDs,
        and providing rapid feedback during development.
      </li>
      <li>
        <strong>Refactor and harden the setup process.</strong><br />
        Once language workflows and hardware integration are well understood,
        revisit the setup scripts to refactor, simplify, and harden the overall
        installation process so the entire system can be rebuilt cleanly and
        predictably.
      </li>
    </ul>
  </div>
</section>



    <section class="section">
  <div class="container">
    

    <section class="section">
      <div class="container">
        <h2>Code & Artifacts</h2>

        <ul>
          <li>
            <strong>setup.sh</strong> —
            <a href="assets/code/pi-py-sandbox-setup.sh">View raw file</a>
          </li>
        </ul>

        <h3>setup.sh (Inline)</h3>
        <p class="muted">
          Bash script used to automate Raspberry Pi sandbox setup, dependency
          installation, and Python environment initialization.
        </p>

        <pre><code>
#!/usr/bin/env bash
set -euo pipefail

# Print the absolute path of this script
realpath "$0"

# Configuration
SANDBOX_ROOT="/home/raspberry/sandbox"
VENV_DIR="$SANDBOX_ROOT/venv"
BOOTSTRAP_SH="$SANDBOX_ROOT/bootstrap.sh"
BASHRC="/home/raspberry/.bashrc"

# Update system packages
sudo apt-get update
sudo apt-get -y upgrade

# Install required packages
sudo apt-get install -y \
  python3 python3-pip python3-venv \
  git tmux screen \
  build-essential minicom

# Create sandbox directory structure
mkdir -p "$SANDBOX_ROOT"/{venv,experiments,esp_tools,protocols,tests,logs}

# Create Python virtual environment if missing
if [ ! -d "$VENV_DIR" ]; then
  python3 -m venv "$VENV_DIR"
fi

# Install Python packages into the venv
"$VENV_DIR/bin/pip" install --upgrade pip
"$VENV_DIR/bin/pip" install pyserial esptool requests flask rich click

# Create bootstrap script to activate the venv
cat <<'BOOTSTRAP' > "$BOOTSTRAP_SH"
#!/usr/bin/env bash
# Safe to source multiple times
if [ -n "${VIRTUAL_ENV:-}" ] && [ "$VIRTUAL_ENV" = "/home/raspberry/sandbox/venv" ]; then
  return 0 2>/dev/null || exit 0
fi

source "/home/raspberry/sandbox/venv/bin/activate"
python --version
printf "Sandbox path: %s\n" "/home/raspberry/sandbox"
BOOTSTRAP

chmod +x "$BOOTSTRAP_SH"

# Ensure .bashrc auto-activates sandbox for interactive shells only
if ! grep -q "sandbox/bootstrap.sh" "$BASHRC"; then
  cat <<'BASHRC_SNIPPET' >> "$BASHRC"

# Auto-activate Raspberry Pi sandbox for interactive shells
if [[ $- == *i* ]]; then
  if [ -f "/home/raspberry/sandbox/bootstrap.sh" ]; then
    source "/home/raspberry/sandbox/bootstrap.sh"
  fi
fi
BASHRC_SNIPPET
fi

# Add user to dialout group for serial access
sudo usermod -aG dialout raspberry

# Reboot reminder
printf "\nSetup complete. Please reboot the Raspberry Pi for group changes to take effect.\n"
        </code></pre>
      </div>
    </section>
<!-- ===================== -->
<!-- NEW PROJECT: CyberPie -->
<!-- ===================== -->
<section class="project">
  <h2>CyberPie (Raspberry Pi Zero 2 W)</h2>
  <p class="project-tagline">
    A portable, service-driven cybersecurity field node with a local TFT UI (no browser required).
  </p>

  <h3>Problem</h3>
  <p>
    When working in a lab or authorized environment, it’s easy to lose time juggling laptops, adapters,
    and “where did that scan output go?” CyberPie is designed to be a small, dedicated field node that
    runs a guided workflow directly on-device.
  </p>

  <h3>Constraints &amp; Goal</h3>
  <p>
    <strong>Constraints:</strong> limited CPU/RAM, power budget, storage, and a small SPI TFT display with
    button/joystick input. Must remain stable even when tools fail or the network is flaky.
  </p>
  <p>
    <strong>Goal:</strong> provide a simple “safe workflow” interface for approved diagnostic/security tasks,
    with consistent logging and predictable operation.
  </p>

  <h3>System Overview</h3>
  <p>
    CyberPie runs as a background service and presents a lightweight on-screen menu UI for launching
    predefined tasks (e.g., local network inventory in a controlled lab, device status checks, log review).
    Outputs are stored locally and can be exported to a workstation for reporting.
  </p>

  <h3>Key Features</h3>
  <ul>
    <li>Service-based architecture (boots into the tool UI without needing a web server)</li>
    <li>Small-screen UX designed for TFT + physical inputs</li>
    <li>Workflow separation: “Safe” menu for approved/standard tasks; expandable “Advanced” area (future)</li>
    <li>Structured logging + exportable artifacts for documentation/reporting</li>
    <li>Fail-safe behavior (tool errors don’t crash the UI; clear status + recovery paths)</li>
  </ul>

  <h3>Tech Stack</h3>
  <ul>
    <li>Raspberry Pi Zero 2 W</li>
    <li>Linux (headless/service-first)</li>
    <li>Python-based UI/menu + system service management</li>
    <li>Modular tool wrappers + logging utilities</li>
  </ul>

  <h3>Status</h3>
  <p>
    Active build and iteration. Focus is on reliability, UI responsiveness, and clean logs.
  </p>
</section>

<!-- =========================== -->
<!-- NEW PROJECT: Security Console -->
<!-- =========================== -->
<section class="project">
  <h2>Security Console (Raspberry Pi 5)</h2>
  <p class="project-tagline">
    A portable “command station” for managing local tooling, logs, and connected field nodes.
  </p>

  <h3>Problem</h3>
  <p>
    A small field node is great, but complex work benefits from a more capable hub for orchestration,
    storage, and review. Security Console is the bigger sibling: a Pi 5-based platform meant to be the
    primary touch interface and control point in an authorized environment.
  </p>

  <h3>Constraints &amp; Goal</h3>
  <p>
    <strong>Constraints:</strong> portable power/thermal management, clean shutdown behavior, and a UI that
    stays usable on a touchscreen without feeling like a full desktop.
  </p>
  <p>
    <strong>Goal:</strong> provide a reliable, self-contained console that can run tools locally, manage data,
    and act as a central review/export point.
  </p>

  <h3>System Overview</h3>
  <p>
    Security Console runs a touchscreen-friendly UI and a set of services for organizing tooling, job runs,
    and outputs. It’s designed to integrate with smaller nodes (like CyberPie) by collecting logs/artifacts
    and presenting them in a consistent, reviewable way.
  </p>

  <h3>Key Features</h3>
  <ul>
    <li>Touchscreen-first interface for launching and monitoring jobs</li>
    <li>Centralized artifact storage (logs, exports, reports-in-progress)</li>
    <li>Service-driven design (stable boot flow, predictable state)</li>
    <li>Designed for compartmentalization and future expansion (containers/modules)</li>
    <li>Operational focus: clarity, repeatability, and documentation-ready outputs</li>
  </ul>

  <h3>Tech Stack</h3>
  <ul>
    <li>Raspberry Pi 5</li>
    <li>Linux + system services</li>
    <li>Modular tooling approach (room for Docker/containers if needed)</li>
    <li>Touch UI + structured logging/export</li>
  </ul>

  <h3>Status</h3>
  <p>
    Active configuration and architecture work. Current focus: platform stability, UI flow, and clean data handling.
  </p>
</section>

    <!-- ===================================================== -->
    <!-- PROJECT TEMPLATE (ANNOTATED – COPY OR UNCOMMENT LATER) -->
    <!-- ===================================================== -->

    <!--
    <section class="section">
      <div class="container">
        <h2>End Goal</h2>
        <p>
          [Describe the intended final form of the project. Focus on system-level
          capability, portability, or operational use.]
        </p>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <h2>Code & Artifacts</h2>
        <ul>
          <li><strong>[script.sh]</strong> — [What the script does]</li>
        </ul>
        <pre><code>
# Paste code here
        </code></pre>
      </div>
    </section>
    -->
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <p class="muted">© <span id="year"></span> Michael Butler. Built for clarity and support roles.</p>
    </div>
  </footer>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>
</body>
</html>

